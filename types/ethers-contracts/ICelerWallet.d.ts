/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface ICelerWalletInterface extends Interface {
  functions: {
    create: TypedFunctionDescription<{
      encode([_owners, _operator, _nonce]: [
        string[],
        string,
        Arrayish
      ]): string;
    }>;

    depositETH: TypedFunctionDescription<{
      encode([_walletId]: [Arrayish]): string;
    }>;

    depositERC20: TypedFunctionDescription<{
      encode([_walletId, _tokenAddress, _amount]: [
        Arrayish,
        string,
        BigNumberish
      ]): string;
    }>;

    withdraw: TypedFunctionDescription<{
      encode([_walletId, _tokenAddress, _receiver, _amount]: [
        Arrayish,
        string,
        string,
        BigNumberish
      ]): string;
    }>;

    transferToWallet: TypedFunctionDescription<{
      encode([_fromWalletId, _toWalletId, _tokenAddress, _receiver, _amount]: [
        Arrayish,
        Arrayish,
        string,
        string,
        BigNumberish
      ]): string;
    }>;

    transferOperatorship: TypedFunctionDescription<{
      encode([_walletId, _newOperator]: [Arrayish, string]): string;
    }>;

    proposeNewOperator: TypedFunctionDescription<{
      encode([_walletId, _newOperator]: [Arrayish, string]): string;
    }>;

    drainToken: TypedFunctionDescription<{
      encode([_tokenAddress, _receiver, _amount]: [
        string,
        string,
        BigNumberish
      ]): string;
    }>;

    getWalletOwners: TypedFunctionDescription<{
      encode([_walletId]: [Arrayish]): string;
    }>;

    getOperator: TypedFunctionDescription<{
      encode([_walletId]: [Arrayish]): string;
    }>;

    getBalance: TypedFunctionDescription<{
      encode([_walletId, _tokenAddress]: [Arrayish, string]): string;
    }>;

    getProposedNewOperator: TypedFunctionDescription<{
      encode([_walletId]: [Arrayish]): string;
    }>;

    getProposalVote: TypedFunctionDescription<{
      encode([_walletId, _owner]: [Arrayish, string]): string;
    }>;
  };

  events: {
    ChangeOperator: TypedEventDescription<{
      encodeTopics([walletId, oldOperator, newOperator]: [
        Arrayish | null,
        string | null,
        string | null
      ]): string[];
    }>;

    CreateWallet: TypedEventDescription<{
      encodeTopics([walletId, owners, operator]: [
        Arrayish | null,
        string[] | null,
        string | null
      ]): string[];
    }>;

    DepositToWallet: TypedEventDescription<{
      encodeTopics([walletId, tokenAddress, amount]: [
        Arrayish | null,
        string | null,
        null
      ]): string[];
    }>;

    DrainToken: TypedEventDescription<{
      encodeTopics([tokenAddress, receiver, amount]: [
        string | null,
        string | null,
        null
      ]): string[];
    }>;

    ProposeNewOperator: TypedEventDescription<{
      encodeTopics([walletId, newOperator, proposer]: [
        Arrayish | null,
        string | null,
        string | null
      ]): string[];
    }>;

    TransferToWallet: TypedEventDescription<{
      encodeTopics([fromWalletId, toWalletId, tokenAddress, receiver, amount]: [
        Arrayish | null,
        Arrayish | null,
        string | null,
        null,
        null
      ]): string[];
    }>;

    WithdrawFromWallet: TypedEventDescription<{
      encodeTopics([walletId, tokenAddress, receiver, amount]: [
        Arrayish | null,
        string | null,
        string | null,
        null
      ]): string[];
    }>;
  };
}

export class ICelerWallet extends Contract {
  connect(signerOrProvider: Signer | Provider | string): ICelerWallet;
  attach(addressOrName: string): ICelerWallet;
  deployed(): Promise<ICelerWallet>;

  on(event: EventFilter | string, listener: Listener): ICelerWallet;
  once(event: EventFilter | string, listener: Listener): ICelerWallet;
  addListener(
    eventName: EventFilter | string,
    listener: Listener
  ): ICelerWallet;
  removeAllListeners(eventName: EventFilter | string): ICelerWallet;
  removeListener(eventName: any, listener: Listener): ICelerWallet;

  interface: ICelerWalletInterface;

  functions: {
    create(
      _owners: string[],
      _operator: string,
      _nonce: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    depositETH(
      _walletId: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    depositERC20(
      _walletId: Arrayish,
      _tokenAddress: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    withdraw(
      _walletId: Arrayish,
      _tokenAddress: string,
      _receiver: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    transferToWallet(
      _fromWalletId: Arrayish,
      _toWalletId: Arrayish,
      _tokenAddress: string,
      _receiver: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    transferOperatorship(
      _walletId: Arrayish,
      _newOperator: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    proposeNewOperator(
      _walletId: Arrayish,
      _newOperator: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    drainToken(
      _tokenAddress: string,
      _receiver: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    getWalletOwners(_walletId: Arrayish): Promise<string[]>;

    getOperator(_walletId: Arrayish): Promise<string>;

    getBalance(_walletId: Arrayish, _tokenAddress: string): Promise<BigNumber>;

    getProposedNewOperator(_walletId: Arrayish): Promise<string>;

    getProposalVote(_walletId: Arrayish, _owner: string): Promise<boolean>;
  };

  create(
    _owners: string[],
    _operator: string,
    _nonce: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  depositETH(
    _walletId: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  depositERC20(
    _walletId: Arrayish,
    _tokenAddress: string,
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  withdraw(
    _walletId: Arrayish,
    _tokenAddress: string,
    _receiver: string,
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  transferToWallet(
    _fromWalletId: Arrayish,
    _toWalletId: Arrayish,
    _tokenAddress: string,
    _receiver: string,
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  transferOperatorship(
    _walletId: Arrayish,
    _newOperator: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  proposeNewOperator(
    _walletId: Arrayish,
    _newOperator: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  drainToken(
    _tokenAddress: string,
    _receiver: string,
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  getWalletOwners(_walletId: Arrayish): Promise<string[]>;

  getOperator(_walletId: Arrayish): Promise<string>;

  getBalance(_walletId: Arrayish, _tokenAddress: string): Promise<BigNumber>;

  getProposedNewOperator(_walletId: Arrayish): Promise<string>;

  getProposalVote(_walletId: Arrayish, _owner: string): Promise<boolean>;

  filters: {
    ChangeOperator(
      walletId: Arrayish | null,
      oldOperator: string | null,
      newOperator: string | null
    ): EventFilter;

    CreateWallet(
      walletId: Arrayish | null,
      owners: string[] | null,
      operator: string | null
    ): EventFilter;

    DepositToWallet(
      walletId: Arrayish | null,
      tokenAddress: string | null,
      amount: null
    ): EventFilter;

    DrainToken(
      tokenAddress: string | null,
      receiver: string | null,
      amount: null
    ): EventFilter;

    ProposeNewOperator(
      walletId: Arrayish | null,
      newOperator: string | null,
      proposer: string | null
    ): EventFilter;

    TransferToWallet(
      fromWalletId: Arrayish | null,
      toWalletId: Arrayish | null,
      tokenAddress: string | null,
      receiver: null,
      amount: null
    ): EventFilter;

    WithdrawFromWallet(
      walletId: Arrayish | null,
      tokenAddress: string | null,
      receiver: string | null,
      amount: null
    ): EventFilter;
  };

  estimate: {
    create(
      _owners: string[],
      _operator: string,
      _nonce: Arrayish
    ): Promise<BigNumber>;

    depositETH(_walletId: Arrayish): Promise<BigNumber>;

    depositERC20(
      _walletId: Arrayish,
      _tokenAddress: string,
      _amount: BigNumberish
    ): Promise<BigNumber>;

    withdraw(
      _walletId: Arrayish,
      _tokenAddress: string,
      _receiver: string,
      _amount: BigNumberish
    ): Promise<BigNumber>;

    transferToWallet(
      _fromWalletId: Arrayish,
      _toWalletId: Arrayish,
      _tokenAddress: string,
      _receiver: string,
      _amount: BigNumberish
    ): Promise<BigNumber>;

    transferOperatorship(
      _walletId: Arrayish,
      _newOperator: string
    ): Promise<BigNumber>;

    proposeNewOperator(
      _walletId: Arrayish,
      _newOperator: string
    ): Promise<BigNumber>;

    drainToken(
      _tokenAddress: string,
      _receiver: string,
      _amount: BigNumberish
    ): Promise<BigNumber>;

    getWalletOwners(_walletId: Arrayish): Promise<BigNumber>;

    getOperator(_walletId: Arrayish): Promise<BigNumber>;

    getBalance(_walletId: Arrayish, _tokenAddress: string): Promise<BigNumber>;

    getProposedNewOperator(_walletId: Arrayish): Promise<BigNumber>;

    getProposalVote(_walletId: Arrayish, _owner: string): Promise<BigNumber>;
  };
}
